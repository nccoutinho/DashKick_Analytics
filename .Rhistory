library(kableExtra)
library(knitr)
hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
lines <- options$output.lines
if (is.null(lines)) {
return(hook_output(x, options))  # pass to default hook
}
x <- unlist(strsplit(x, "\n"))
more <- "..."
if (length(lines)==1) {        # first n lines
if (length(x) > lines) {
# truncate the output, but add ....
x <- c(head(x, lines), more)
}
} else {
x <- c(more, x[lines], more)
}
# paste these lines together
x <- paste(c(x, ""), collapse = "\n")
hook_output(x, options)
})
library(rjson)
library(tidyverse, quietly = TRUE)
movies <- fromJSON(file = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
# YOUR ANSWER GOES HERE
head(movies)
tail(movies)
glimpse(movies)
movies %>%
select_if(is.numeric) %>%
summary(movies)
library(ggplot2)
# Create a histogram plot
histogram_plot <- ggplot(movies, aes(x = budget)) +
geom_histogram(bins = 15, fill = "coral3", color = "black", alpha = 0.5) +
labs(title = "Histogram of Budget",
x = "Budget",
y = "Frequency") +
theme_minimal()
print(histogram_plot)
# Create a kernel density estimate plot
kde_plot <- ggplot(movies, aes(x = budget)) +
geom_density(fill = "cornflowerblue", color = "black", alpha = 0.5) +  # Adjust alpha for opacity
labs(title = "Kernel Density Estimate of Budget",
x = "Budget",
y = "Density") +
theme_minimal()
# Print the KDE plot
print(kde_plot)
# Select numerical columns (excluding 'id') and reshape data for faceting
# Assuming 'movies_numeric' is our data frame with numerical columns (except 'id')
movies_numeric <- movies %>%
select_if(is.numeric) %>%
gather(key = "variable", value = "value", -id)
# Create a density plot with faceting
density_facet_plot <- ggplot(movies_numeric, aes(x = value)) +
geom_density(aes(fill = variable), color = "black", alpha = 0.2) +
labs(title = "Density Plots for Numerical Columns",
x = "Numerical Values",
y = "Density") +
theme_minimal() +
facet_wrap(~variable, scales = "free", ncol = 2)
# Print the density facet plot
print(density_facet_plot)
# Load necessary libraries
library(GGally)
# Assuming 'movies' is your data frame with numerical columns (except 'id')
# Select numerical columns (excluding 'id')
movies_numeric <- movies %>%
select_if(is.numeric) %>%
select(-id)  # Exclude 'id'
# Create a scatterplot matrix using GGally
scatterplot_matrix <- ggpairs(movies_numeric,
title = "Scatterplot Matrix",
lower = list(
continuous = wrap("points", alpha = 0.5, size = 1)
)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the scatterplot matrix
scatterplot_matrix
# Create a correlation plot using GGally
correlation_plot <- ggcorr(movies_numeric, title = "Correlation Matrix", label = TRUE)
correlation_plot
# Create a correlation plot using GGally
correlation_plot <- ggcorr(movies_numeric, label = TRUE)
correlation_plot
# Create a correlation plot using GGally
correlation_plot <- ggcorr(movies_numeric, label = TRUE)
correlation_plot <- correlation_plot + ggtitle("Correlation Matrix")
correlation_plot
# Create a correlation plot using GGally
correlation_plot <- ggcorr(movies_numeric, label = TRUE)
correlation_plot <- correlation_plot + ggtitle("Correlation Matrix") +
theme(plot.title = element_text(hjust = 0.5))
correlation_plot
free_genres <- movies %>% unnest(genres)
free_genres <- free_genres %>% unnest(genres)  %>%
group_by(genres) %>%
summarise(median_revenue = median(revenue, na.rm = TRUE))
# Sort the genres by median revenue
sorted_genres <- free_genres %>%
arrange(median_revenue) %>%
pull(genres)
# Create boxplots with genres on the y-axis and revenue on the x-axis
boxplot_plot <- movies %>%
unnest(genres) %>%
ggplot(aes(x = revenue, y = genres)) +
geom_boxplot() +
scale_y_discrete(limits = sorted_genres) +
labs(title = "Boxplots of Revenue by Genre",
x = "Revenue",
y = "Genres") +
theme_minimal()
boxplot_plot
genres_data <- movies %>%
unnest(genres) %>%
group_by(genres) %>%
summarise(count = n()) %>%
arrange(desc(count))
barplot_plot <-  ggplot(genres_data, aes(x = fct_reorder(genres, desc(count)), y = count)) +
geom_bar(stat = "identity", fill = "skyblue") +
labs(title = "Number of Movies by Genre",
x = "Genre",
y = "Count") +
theme_minimal() +
coord_flip()
barplot_plot
# Create boxplots for all numerical values
# Unnest genres twice and calculate median for each genre
free_genres <- movies %>%
unnest(genres)
free_genres <- movies %>%
unnest(genres) %>%
group_by(genres) %>%
select(-id) %>%
summarise(across(where(is.numeric), median, na.rm = TRUE))
# Sort genres by median for each numerical variable
sorted_genres <- free_genres %>%
arrange(across(where(is.numeric))) %>%
pull(genres)
# Create boxplots using faceting for all numerical values
boxplot_plots <- free_genres %>%
gather(key = "variable", value = "value", -genres) %>%
mutate(variable = as.factor(variable)) %>%
ggplot(aes(x = value, y = genres)) +
geom_boxplot() +
scale_y_discrete(limits = sorted_genres) +
labs(title = "Boxplots by Genre and Numerical Values",
x = "Value",
y = "Genres") +
facet_wrap(~variable, scales = "free", ncol = 2) +
theme_minimal()
# Print the faceted boxplot
print(boxplot_plots)
# Create violinplots for revenue by genre
movies_sorted <- movies %>%
unnest(genres) %>%
group_by(genres) %>%
mutate(median_revenue = median(revenue),
median_sort = median_revenue) %>%
ungroup() %>%
arrange(median_revenue)
# Create violin plot with a line for the median, sorted by median revenue
violinplot_plot <- ggplot(movies_sorted,
aes(x = revenue, y = factor(genres, levels = unique(genres)), fill = genres)) +
geom_violin() +
stat_summary(fun = "median", geom = "line", aes(group = 1), color = "red", size = 1) +  # Add median line
labs(title = "Revenue by Genre",
x = "Revenue",
y = "Genre") +
theme_minimal()
violinplot_plot
movies_sorted_numeric <- movies_sorted %>%
select_if(is.numeric) %>% # Only select numeric columns
select(-id) %>%
select(-median_sort)
movies_sorted_long <- movies_sorted %>%
select(c('genres', 'median_revenue', names(movies_sorted_numeric))) %>%  # add genre or other categorical column
pivot_longer(cols = -c(genres, median_revenue), names_to = "metric", values_to = "value")
violinplot_plot_all <- ggplot(movies_sorted_long,
aes(x = value, y = factor(genres, levels = unique(genres)), fill = genres)) +
geom_violin() +
stat_summary(fun = "median", geom = "line", aes(group = 1), color = "red", size = 1) +
labs(x = "Value",
y = "Genre") +
facet_wrap(~metric, scales = "free", ncol = 2) +
theme_minimal()
print(violinplot_plot_all)
movies_sorted_numeric <- movies_sorted %>%
select_if(is.numeric) %>% # Only select numeric columns
select(-id) %>%
select(-median_sort)
movies_sorted_long <- movies_sorted %>%
select(c('genres', 'median_revenue', names(movies_sorted_numeric))) %>%  # add genre or other categorical column
pivot_longer(cols = -c(genres, median_revenue), names_to = "metric", values_to = "value")
violinplot_plot_all <- ggplot(movies_sorted_long,
aes(x = value, y = factor(genres, levels = unique(genres)), fill = genres)) +
geom_violin(scale = "count") +
stat_summary(fun = "median", geom = "line", aes(group = 1), color = "red", size = 1) +
labs(x = "Value",
y = "Genre") +
facet_wrap(~metric, scales = "free", ncol = 2) +
theme_minimal()
print(violinplot_plot_all)
library(tidyr)
library(GGally)
# Unnest 'studio' and 'genres' columns
studio_genres <- movies %>%
unnest(genres) %>%
unnest(studios)
# Count the total number of movies in each combination of genres and studio
count_combinations <- studio_genres %>%
add_count(studios, genres, name = "n")
# Create a heatmap of counts
heatmap_plot <- ggplot(count_combinations, aes(x = studios, y = genres, fill = n)) +
geom_tile() +
labs(title = "Heatmap of Movie Counts by Studio and Genre",
x = "Studio",
y = "Genre",
fill = "Number of Movies")  +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
heatmap_plot
library(ggforce)
ggally_barDiag(count_combinations, aes(x = genres, y = studios, fill = genres))  +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(tidyverse)
# Assuming your data frame is named 'your_data' and it has 'studio' and 'genres' columns
# Unnest the 'studio' and 'genres' columns
unnested_data <- movies %>%
unnest(genres) %>%
unnest(studios)
# Calculate the proportion for each studio-genre pair
proportion_data <- unnested_data %>%
count(studios, genres) %>%
group_by(studios) %>%
mutate(proportion = n / sum(n))
# Create a categorical count plot with proportions
proportion_plot <- ggplot(proportion_data, aes(x = studios, y = proportion, fill = genres)) +
geom_col(position = "stack") +
labs(title = "Proportion of Genres within Each Studio",
x = "Studio", y = "Proportion", fill = "Genre") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Show the plot
print(proportion_plot)
library(ggforce)
#ggally_barDiag(count_combinations, aes(x = genres, y = studios, fill = genres)) +
# theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggally_points(count_combinations, mapping = aes(x = studios, y = genres, color = n, size = n)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(ggforce)
ggally_barDiag(count_combinations, aes(x = genres, y = studios, fill = genres))  +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(ggforce)
ggally_barDiag(count_combinations, aes(x = studios, y = genres, fill = genres))  +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(rjson)
library(tidyverse, quietly = TRUE)
movies <- fromJSON(file = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
head(movies)
# YOUR ANSWER GOES HERE
tail(movies)
# Create boxplots for all numerical values
# Unnest genres twice and calculate median for each genre
free_genres <- movies %>%
unnest(genres) %>%
unnest(genres) %>%
group_by(genres) %>%
select(-id) %>%
summarise(across(where(is.numeric), median, na.rm = TRUE))
# Sort genres by median for each numerical variable
sorted_genres <- free_genres %>%
arrange(across(where(is.numeric))) %>%
pull(genres)
# Create boxplots using faceting for all numerical values
boxplot_plots <- free_genres %>%
gather(key = "variable", value = "value", -genres) %>%
mutate(variable = as.factor(variable)) %>%
ggplot(aes(x = value, y = genres)) +
geom_boxplot() +
scale_y_discrete(limits = sorted_genres) +
labs(title = "Boxplots by Genre and Numerical Values",
x = "Value",
y = "Genres") +
facet_wrap(~variable, scales = "free", ncol = 2) +
theme_minimal()
# Print the faceted boxplot
print(boxplot_plots)
# Create violinplots for revenue by genre
movies_sorted <- movies %>%
unnest(genres) %>%
group_by(genres) %>%
mutate(median_revenue = median(revenue),
median_sort = median_revenue) %>%
ungroup() %>%
arrange(median_revenue)
# Create violin plot with a line for the median, sorted by median revenue
violinplot_plot <- ggplot(movies_sorted,
aes(x = revenue, y = factor(genres, levels = unique(genres)), fill = genres)) +
geom_violin() +
stat_summary(fun = "median", geom = "line", aes(group = 1), color = "red", size = 1) +  # Add median line
labs(title = "Revenue by Genre",
x = "Revenue",
y = "Genre") +
theme_minimal()
violinplot_plot
library(ggforce)
ggally_barDiag(count_combinations, aes(x = studios, y = genres, fill = genres))  +
labs(title = "Stacked Barplot of Movie Counts by Studio and Genre",
x = "Studio",
y = "Genre",
fill = "Number of Movies") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(ggforce)
ggally_barDiag(count_combinations, aes(x = studios, y = genres, fill = genres))  +
labs(title = "Stacked Barplot of Movie Counts by Studio and Genre",
x = "Studio",
y = "Number of Movies",
fill = "Number of Movies") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(ggforce)
ggally_barDiag(count_combinations, aes(x = studios, y = genres, fill = genres))  +
labs(title = "Stacked Barplot of Movie Counts by Studio and Genre",
x = "Studio",
y = "Genre",
fill = "Number of Movies") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(ggforce)
ggally_barDiag(count_combinations, aes(x = studios, y = genres, fill = genres))  +
labs(title = "Stacked Barplot of Movie Counts by Studio and Genre",
x = "Studio",
y = "Number of Movies",
fill = "Number of Movies") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(ggforce)
ggally_barDiag(count_combinations, aes(x = studios, y = genres, fill = genres))  +
labs(title = "Stacked Barplot of Movie Counts by Studio and Genre",
x = "Studio",
y = "Number of Movies",
fill = "Number of Movies") +
scale_fill_discrete(name = "Genre") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(ggforce)
ggally_barDiag(count_combinations, aes(x = studios, y = genres, fill = genres))  +
labs(title = "Stacked Barplot of Movie Counts by Studio and Genre",
x = "Studio",
y = "Number of Movies",
fill = "Genre") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(rjson)
library(tidyverse, quietly = TRUE)
movies <- fromJSON(file = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
# YOUR ANSWER GOES HERE
head(movies)
# YOUR ANSWER GOES HERE
tail(movies)
glimpse(movies)
library(rjson)
library(tidyverse, quietly = TRUE)
movies <- fromJSON(file = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
# YOUR ANSWER GOES HERE
head(movies)
# YOUR ANSWER GOES HERE
tail(movies)
glimpse(movies)
library(rjson)
library(tidyverse, quietly = TRUE)
movies <- fromJSON(file = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
# YOUR ANSWER GOES HERE
head(movies)
tail(movies)
library(rjson)
library(tidyverse, quietly = TRUE)
movies <- fromJSON(file = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
# YOUR ANSWER GOES HERE
head(movies)
tail(movies)
totalpts = bonuspts =0
ipoint <- function(x, bonus = FALSE){
if (bonus){
paste(paste("(",x,sep="") , ifelse(x == 1, "bonus pt)", "bonus pts)"))
} else {
paste(paste("(",x,sep="") , ifelse(x == 1, "pt)", "pts)"))
}
}
totalpts = totalpts + 2
tail(movies)
glimpse(movies)
totalpts = bonuspts =0
ipoint <- function(x, bonus = FALSE){
if (bonus){
paste(paste("(",x,sep="") , ifelse(x == 1, "bonus pt)", "bonus pts)"))
} else {
paste(paste("(",x,sep="") , ifelse(x == 1, "pt)", "pts)"))
}
}
totalpts = totalpts + 2
tail(movies)
glimpse(movies)
totalpts = bonuspts =0
ipoint <- function(x, bonus = FALSE){
if (bonus){
paste(paste("(",x,sep="") , ifelse(x == 1, "bonus pt)", "bonus pts)"))
} else {
paste(paste("(",x,sep="") , ifelse(x == 1, "pt)", "pts)"))
}
}
totalpts = totalpts + 2
tail(movies)
glimpse(movies)
glimpse(movies)
glimpse(movies)
glimpse(movies)
library(rjson)
library(tidyverse)
library(dplyr)
movies <- fromJSON(file = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
# YOUR ANSWER GOES HERE
head(movies)
tail(movies)
glimpse(movies)
movies %>%
select_if(is.numeric) %>%
summary(movies)
library(ggplot2)
# Create a histogram plot
histogram_plot <- ggplot(movies, aes(x = budget)) +
geom_histogram(bins = 15, fill = "coral3", color = "black", alpha = 0.5) +
labs(title = "Histogram of Budget",
x = "Budget",
y = "Frequency") +
theme_minimal()
print(histogram_plot)
library(rjson)
library(tidyverse)
library(dplyr)
movies <- fromJSON(txt = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
library(rjson)
library(tidyverse)
library(dplyr)
library(jsonlite)
movies <- fromJSON(txt = 'lab2-movies.json') %>%
as_tibble() %>%
unnest(-c(studios, genres))
# YOUR ANSWER GOES HERE
head(movies)
# Example usage:
# Assuming you have a dataset named "match.csv"
# Note: Make sure the column names match those in your actual dataset
# If the timestamp column is in character format, convert it to POSIXct
match_data$Date <- as.POSIXct(match_data$FixtureDate)
# Load your dataset
match_data <- read.csv("match_data.csv")
setwd("/Users/nats/DashKick_Analytics")
# Load your dataset
match_data <- read.csv("match_data.csv")
match_data
predict_win <- function(training_data, new_data) {
# Ensure that the necessary columns are present in the data
if (!all(c("HomeTeam", "AwayTeam", "FT_ScoreHome", "FT_ScoreAway", "FixtureDate") %in% colnames(training_data))) {
stop("Required columns (HomeTeam, AwayTeam, FT_ScoreHome, FT_ScoreAway, FixtureDate) not found in training data.")
}
# Create a binary outcome variable (1 if home team wins, 0 otherwise)
training_data$Outcome <- ifelse(training_data$FT_ScoreHome > training_data$FT_ScoreAway, 1, 0)
# Train logistic regression model
model <- glm(Outcome ~ FT_ScoreHome + FT_ScoreAway, data = training_data, family = binomial)
# Make predictions on new data
new_data$PredictedOutcome <- predict(model, newdata = new_data, type = "response")
# Convert predicted probabilities to binary outcome
new_data$PredictedOutcome <- ifelse(new_data$PredictedOutcome > 0.5, 1, 0)
return(new_data$PredictedOutcome)
# Define the predict_win function
predict_win <- function(training_data, new_data) {
# Ensure that the necessary columns are present in the data
if (!all(c("HomeTeam", "AwayTeam", "FT_ScoreHome", "FT_ScoreAway", "FixtureDate") %in% colnames(training_data))) {
stop("Required columns (HomeTeam, AwayTeam, FT_ScoreHome, FT_ScoreAway, FixtureDate) not found in training data.")
}
# Create a binary outcome variable (1 if home team wins, 0 otherwise)
training_data$Outcome <- ifelse(training_data$FT_ScoreHome > training_data$FT_ScoreAway, 1, 0)
# Train logistic regression model
model <- glm(Outcome ~ FT_ScoreHome + FT_ScoreAway, data = training_data, family = binomial)
# Make predictions on new data
new_data$PredictedOutcome <- predict(model, newdata = new_data, type = "response")
# Convert predicted probabilities to binary outcome
new_data$PredictedOutcome <- ifelse(new_data$PredictedOutcome > 0.5, 1, 0)
return(new_data$PredictedOutcome)
}
# Create a subset of data for training and testing (adjust as needed)
training_data <- match_data[1:800, ]
new_data <- match_data[801:1000, ]
# Make predictions
predictions <- predict_win(training_data, new_data)
print(predictions)
match_data <- read.csv("match_data.csv")
match_data
